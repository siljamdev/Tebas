using System;
using AshLib.AshFiles;
using AshLib.Folders;
using AshLib.Dates;

class Tebas{
	//Context variables
	
	public static bool quiet;
	public static Dependencies dep;
	public static AshFile config;
	
	public static AshFile template;
	public static string tn; //templateName
	public static string templateDirectory;
	
	public static AshFile project;
	public static string pn; //projectName
	
	public static string workingDirectory;
	
	//private initilization vars
	private static bool configInit;
	private static bool localInit;
	
	public const string currentVersion = "v0.3.4";
	
	public static void Main(string[] args){
		workingDirectory = Directory.GetCurrentDirectory();
		
		initialize();
		
		//DebugHelper.firstTest();
		
		try{
			CommandLineHandler.process(args);
		}catch(TebasError te){
			Console.WriteLine(te);
		}catch(TebasCriticalError tce){
			Console.WriteLine(tce);
		}
		
	}
	
	//Initialize methods
	
	static void initialize(){
		string appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
		dep = new Dependencies(appDataPath + "/ashproject/tebas", true, new string[]{"templates"}, null);
	}
	
	public static void initializeConfig(){
		if(configInit){
			return;
		}
		
		config = dep.config;
		
		config.InitializeCamp("deletionConfirmationNeeded", true);
		config.InitializeCamp("scriptShowsName", false);
		config.InitializeCamp("processShowsName", true);
		
		config.InitializeCamp("git.autoAddOnCommit", false);
		
		config.InitializeCamp("defaultReadme", "Auto generated by Tebas project manager\n");
		
		config.InitializeCamp("git.defaultGitignore", "#Auto generated by Tebas project manager\n/desktop.ini\n.git/\n/.gitignore\n/project.tebas");
		config.InitializeCamp("git.path", "git");
		config.InitializeCamp("git.defaultBranch", "main");
		
		config.Save();
		configInit = true;
	}
	
	public static bool initializeLocal(){
		if(localInit){
			return true;
		}
		
		if(!setContextLocal()){
			return false;
		}
		
		if(project.CanGetCamp("template", out string ten)){
			setContextTemplate(ten);
		}else{
			consoleOutput("The local project has no referenced template: bad formatting of project.tebas");
		}
		
		localInit = true;
		return true;
	}
	
	public static bool initializeLocalSilent(){
		if(localInit){
			return true;
		}
		
		if(!setContextLocal()){
			return false;
		}
		
		if(project.CanGetCamp("template", out string ten)){
			setContextTemplate(ten);
		}
		
		localInit = true;
		return true;
	}
	
	//attempt to tidy this up :'(
	
	public static bool setContextTemplate(string templateName){
		if(!TemplateHandler.exists(templateName)){
			consoleOutput("That template is not installed");
			return false;
		}
		
		tn = templateName;
		
		template = TemplateHandler.get(tn);
		
		templateDirectory = templateDirectory = dep.path + "/templates/" + tn;
		//workingDirectory = templateDirectory; //Because if only template then this ykyk (i have no idea of what im doing)
		
		return true;
	}
	
	public static bool setContextLocal(){ //project
		string f = workingDirectory;
		while(true){
			if(File.Exists(f + "/project.tebas")){
				break;
			}
			
			f = Path.GetDirectoryName(f);
			if(f == null){
				consoleOutput("There is no local project in this folder: " + workingDirectory);
				return false;
			}
		}
		
		workingDirectory = f;
		
		project = new AshFile(workingDirectory + "/project.tebas");
		
		pn = Path.GetFileName(workingDirectory);
		
		return true;
	}
	
	public static bool setContextFull(){ //project and template, from local source
		string f = workingDirectory;
		while(true){
			if(File.Exists(f + "/project.tebas")){
				break;
			}
			
			f = Path.GetDirectoryName(f);
			if(f == null){
				consoleOutput("There is no local project in this folder: " + workingDirectory);
				return false;
			}
		}
		
		workingDirectory = f;
		
		project = new AshFile(workingDirectory + "/project.tebas");
		
		pn = Path.GetFileName(workingDirectory);
		
		if(project.CanGetCamp("template", out string t)){
			if(!TemplateHandler.exists(t)){
				consoleOutput("The template referenced in this project is not installed: " + t);
				return false;
			}
			tn = t;
			
			template = TemplateHandler.get(tn);
			
			templateDirectory = dep.path + "/templates/" + tn;
			return true;
		}else{
			consoleOutput("The local project has no referenced template: bad formatting of project.tebas");
			return false;
		}
	}
	
	//Commands
	
	public static void version(){
		consoleOutput("Current version: " + currentVersion);
	}
	
	//Project
	
	public static void projectNew(string channelName, string templateName, string projectName){
		initializeConfig();
		
		string folderPath;
		
		if(!ChannelHandler.canGetPath(channelName, out folderPath)){
			consoleOutput("That channel does not exist");
			return;
		}
		
		if(!setContextTemplate(templateName)){
			return;
		}
		
		if(projectExists(folderPath, projectName)){
			consoleOutput("That project already exists");
			return;
		}
		
		pn = projectName;
		
		workingDirectory = folderPath + "/" + projectName;
		
		consoleOutput("Attempting to create in channel " + channelName + ", folder \"" + folderPath + "\"");
		
		Directory.CreateDirectory(workingDirectory);
		Directory.SetCurrentDirectory(workingDirectory);
		
		project = new AshFile();
		
		project.SetCamp("template", templateName);
		project.SetCamp("creationDate", (Date) DateTime.Now);
		
		if(template.CanGetCamp("git.defaultUse", out bool b) && b){
			project.SetCamp("git.use", true);
			
			GitHelper.init();
			
			string gitIgnore = "";
			if(config.CanGetCamp("git.defaultGitignore", out string k)){
				gitIgnore = k;
			}
			
			if(template.CanGetCamp("git.gitignore", out k)){
				gitIgnore += "\n" + k;
			}
			
			if(gitIgnore.Length > 0 && !File.Exists(workingDirectory + "/.gitignore")){
				File.WriteAllText(workingDirectory + "/.gitignore", gitIgnore);
			}
		}else{
			project.SetCamp("git.use", false);
		}
		
		if(!(template.CanGetCamp("addReadme", out b) && !b)){
			string readme = "";
			if(config.CanGetCamp("defaultReadme", out string s)){
				readme = s;
			}
			
			if(template.CanGetCamp("readme", out s)){
				readme += s;
			}
			
			if(readme.Length > 0 && !File.Exists(workingDirectory + "/README.md")){
				File.WriteAllText(workingDirectory + "/README.md", readme);
			}
		}
		
		project.Save(workingDirectory + "/project.tebas");
		
		TemplateHandler.runScript("new");
		
		consoleOutput("Project succesfully created");
	}
	
	public static void projectRename(string channelName, string oldName, string newName){
		string folderPath;
		
		if(!ChannelHandler.canGetPath(channelName, out folderPath)){
			consoleOutput("That channel does not exist");
			return;
		}

		if(!projectExists(folderPath, oldName)){
			consoleOutput("That project you want to rename does not exist");
			return;
		}
		
		if(projectExists(folderPath, newName)){
			consoleOutput("That name is already in use");
			return;
		}
		
		pn = oldName;
		
		workingDirectory = folderPath + "/" + oldName;
		
		consoleOutput("Attempting to rename in channel " + channelName + ", folder \"" + folderPath + "\"");
		
		Directory.Move(workingDirectory, folderPath + "/" + newName);
		
		workingDirectory = folderPath + "/" + newName;
		
		Directory.SetCurrentDirectory(workingDirectory);
		
		pn = newName;
		
		TemplateHandler.runScript("rename");
		
		consoleOutput("Project succesfully renamed");
	}
	
	public static void projectDelete(string channelName, string name){
		string folderPath;
		
		if(!ChannelHandler.canGetPath(channelName, out folderPath)){
			consoleOutput("That channel does not exist");
			return;
		}

		if(!projectExists(folderPath, name)){
			consoleOutput("That project does not exist");
			return;
		}
		
		if(!askDeletionConfirmation()){
			consoleOutput("Deletion cancelled");
			return;
		}
		
		consoleOutput("Attempting to delete in channel " + channelName + ", folder \"" + folderPath + "\"");
		
		Directory.Delete(folderPath + "/" + name, true);
		
		consoleOutput("Project succesfully deleted");
	}
	
	//Global
	public static void globalConfig(string key, string val){
		initializeConfig();
		
		switch(key){
			case "list":
			consoleOutput("List of config options:");
			consoleOutput("  deleteConfirm   - If you have to confirm every deletion");
			consoleOutput("  scriptLogName   - If template scripts will show the name of the script");
			consoleOutput("  readme          - The default readme file for projects. Requires a file path");
			consoleOutput("  gitignore       - The default .gitignore file for projects that use git. Requires a file path");
			consoleOutput("  gitPath         - The path to the git executable");
			consoleOutput("  gitBranch       - The main branch that will be used for all git related stuff");
			consoleOutput("  gitAddOnCommit  - Automatically adds all changes when commiting");
			break;
			
			case "deleteConfirm":
			setConfigTrueFalse("deletionConfirmationNeeded", val);
			break;
			
			case "scriptLogName":
			setConfigTrueFalse("scriptShowsName", val);
			break;
			
			case "processLogName":
			setConfigTrueFalse("processShowsName", val);
			break;
			
			case "readme":
			if(!File.Exists(val)){
				consoleOutput("That file does not exsist");
				break;
			}
			config.SetCamp("defaultReadme", File.ReadAllText(val));
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitignore":
			if(!File.Exists(val)){
				consoleOutput("That file does not exsist");
				break;
			}
			config.SetCamp("git.defaultGitignore", File.ReadAllText(val));
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitPath":
			config.SetCamp("git.path", val);
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitBranch":
			config.SetCamp("git.defaultBranch", val);
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitAddOnCommit":
			setConfigTrueFalse("git.autoAddOnCommit", val);
			break;
			
			case "see":
			consoleOutput("Current config values:");
			
			if (config.CanGetCamp("deletionConfirmationNeeded", out bool deleteConfirm)){
				consoleOutput("  deleteConfirm: " + deleteConfirm);
			}
			
			if (config.CanGetCamp("scriptShowsName", out bool scriptLogName)){
				consoleOutput("  scriptLogName: " + scriptLogName);
			}
			
			if (config.CanGetCamp("processShowsName", out bool processLogName)){
				consoleOutput("  processLogName: " + processLogName);
			}
			
			if (config.CanGetCamp("defaultReadme", out string readme)){
				consoleOutput("  readme: " + readme);
			}
			
			if (config.CanGetCamp("git.defaultGitignore", out string gitignore)){
				consoleOutput("  gitignore: " + gitignore);
			}
			
			if (config.CanGetCamp("git.path", out string gitPath)){
				consoleOutput("  gitPath: " + gitPath);
			}
			
			if (config.CanGetCamp("git.defaultBranch", out string gitBranch)){
				consoleOutput("  gitBranch: " + gitBranch);
			}
			
			if (config.CanGetCamp("git.autoAddOnCommit", out bool gitAddOnCommit)){
				consoleOutput("  gitAddOnCommit: " + gitAddOnCommit);
			}
			break;
			
			default:
			consoleOutput("That key isnt a config option. Do \'config list\' to see the full list");
			break;
		}
	}
	
	public static void globalList(){
		string[] names = ChannelHandler.allNames();
		
		if(names.Length > 0){
			consoleOutput("Full list of projects: ");
		}
		
		foreach(string n in names){
			consoleOutput("Channel: " + n);
			
			if(!Directory.Exists(ChannelHandler.getPath(n))){
				continue;
			}
			string[] directories = Directory.GetDirectories(ChannelHandler.getPath(n));
			
			foreach(string s in directories){
				if(File.Exists(s + "/project.tebas")){
					consoleOutput("    " + Path.GetFileName(s));
				}
			}
		}
	}
	
	static void setConfigTrueFalse(string key, string val){
		if(val == "true"){
			config.SetCamp(key, true);
			config.Save();
			consoleOutput("Config changed correctly");
		}else if(val == "false"){
			config.SetCamp(key, false);
			config.Save();
			consoleOutput("Config changed correctly");
		}else{
			consoleOutput("The value must be \"true\" or \"false\"");
		}
	}
	
	//local
	
	
	public static void localInfo(){
		if(!initializeLocal()){
			return;
		}
		
		consoleOutput("Project name: " + pn);
		consoleOutput("Project folder: " + workingDirectory);
		if(project.CanGetCamp("creationDate", out Date d)){
			consoleOutput("Date of creation: " + d);
		}
		
		
		if(!TemplateHandler.exists(tn)){
			return;
		}
		
		consoleOutput("Template in use: " + tn);
		
		TemplateHandler.runScript("info");
	}
	
	public static void localGit(){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.status();
			TemplateHandler.runScript("git");
		}else{
			consoleOutput("Git is not used in this project");
		}
	}
	
	public static void localStats(){
		if(!setContextFull()){
			return;
		}
		
		if(!template.CanGetCamp("codeExtensions", out string x)){
			consoleOutput("The template does not have code file extensions");
			TemplateHandler.runScript("stats");
			return;
		}
		
		if(!template.CanGetCamp("codeFilesFolderBlacklist", out string b)){
			consoleOutput("The template does not have code file folder blacklist.");
			TemplateHandler.runScript("stats");
			return;
		}
		
		string[] exs = x.Split(new string[]{"\r\n", "\n", "\r"}, StringSplitOptions.None);
		string[] bs = b.Split(new string[]{"\r\n", "\n", "\r"}, StringSplitOptions.None);
		
		for(int i = 0; i < bs.Length; i++){
			bs[i] = workingDirectory + "/" + bs[i];
		}
		
		List<string> files = GetFilesWithExtensions(workingDirectory, exs, bs);
		
		int l = 0;
		foreach(string p in files){
			l += File.ReadAllLines(p).Length;
		}
		
		consoleOutput("Total number of code lines: " + l);
		
		TemplateHandler.runScript("stats");
	}
	
	public static void localAdd(){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.add();
			
			TemplateHandler.runScript("add");
		}else{
			consoleOutput("Git is not used in this project");
		}
	}
	
	public static void localCommit(string m){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.commit(m);
			
			TemplateHandler.runScript("commit");
		}else{
			consoleOutput("Git is not used in this project");
		}
	}
	
	public static void localPush(string r){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.push(r);
			
			TemplateHandler.runScript("push");
		}else{
			consoleOutput("Git is not used in this project");
		}
	}
	
	public static void localPull(string r){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.pull(r);
			
			TemplateHandler.runScript("pull");
		}else{
			consoleOutput("Git is not used in this project");
		}
	}
	
	public static void localInitNew(string templateName){
		initializeConfig();
		
		string folderPath = workingDirectory;
		
		if(!setContextTemplate(templateName)){
			return;
		}
		
		if(File.Exists("project.tebas")){
			consoleOutput("There is a project already here");
			return;
		}
		
		pn = Path.GetFileName(folderPath);
		
		project = new AshFile();
		
		project.SetCamp("template", templateName);
		project.SetCamp("creationDate", (Date) DateTime.Now);
		
		if(template.CanGetCamp("git.defaultUse", out bool b) && b){
			project.SetCamp("git.use", true);
			
			GitHelper.init();
			
			string gitIgnore = "";
			if(config.CanGetCamp("git.defaultGitignore", out string k)){
				gitIgnore = k;
			}
			
			if(template.CanGetCamp("git.gitignore", out k)){
				gitIgnore += "\n" + k;
			}
			
			if(gitIgnore.Length > 0 && !File.Exists(workingDirectory + "/.gitignore")){
				File.WriteAllText(workingDirectory + "/.gitignore", gitIgnore);
			}
		}else{
			project.SetCamp("git.use", false);
		}
		
		if(!(template.CanGetCamp("addReadme", out b) && !b)){
			string readme = "";
			if(config.CanGetCamp("defaultReadme", out string s)){
				readme = s;
			}
			
			if(template.CanGetCamp("readme", out s)){
				readme += s;
			}
			
			if(readme.Length > 0 && !File.Exists(workingDirectory + "/README.md")){
				File.WriteAllText(workingDirectory + "/README.md", readme);
			}
		}
		
		project.Save(workingDirectory + "/project.tebas");
		
		TemplateHandler.runScript("new");
		
		consoleOutput("Project succesfully initiallized locally");
	}
	
	//local config remote
	
	public static void localRemoteList(){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.printAllRemotes();
	}
	
	public static void localRemoteSet(string n, string u){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.remoteSet(n, u);
	}
	
	public static void localRemoteDelete(string n){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.remoteDelete(n);
	}
	
	public static void localRemoteRename(string o, string n){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.remoteRename(o, n);
	}
	
	//Template scripts
	
	public static bool tryScript(string name){
		if(!initializeLocalSilent()){
			consoleOutput("Unknown command");
			return false;
		}
		
		if(!TemplateHandler.runScript(name)){
			consoleOutput("Unknown command");
			return false;
		}
		
		return true;
	}
	
	public static bool tryScript(string name, IEnumerable<string> args){
		if(!initializeLocalSilent()){
			consoleOutput("Unknown command");
			return false;
		}
		
		if(!TemplateHandler.runScript(name, args)){
			consoleOutput("Unknown command");
			return false;
		}
		
		return true;
	}
	
	//Standalone scripts
	public static void runStandaloneScript(string filePath){
		filePath = StringHelper.removeQuotesSingle(filePath);
		
		if(!File.Exists(filePath)){
			consoleOutput("File not found");
			return;
		}
		
		template = null;
		tn = "";
		templateDirectory = "";
		project = null;
		pn = "";
		
		Script s = new Script(Path.GetFileNameWithoutExtension(filePath), File.ReadAllText(filePath));
		s.run(null);
	}
	
	public static void runStandaloneScript(string filePath, IEnumerable<string> args){
		filePath = StringHelper.removeQuotesSingle(filePath);
		
		if(!File.Exists(filePath)){
			consoleOutput("File not found");
			return;
		}
		
		template = null;
		tn = "";
		templateDirectory = "";
		project = null;
		pn = "";
		
		Script s = new Script(Path.GetFileNameWithoutExtension(filePath), File.ReadAllText(filePath));
		s.run(args);
	}
	
	//loop
	public static void loop(){
		Tebas.quiet = false;
		consoleOutput(" Exit typing 'exit'");
		string s;
		while(true){
			Console.Write(">");
			s = Console.ReadLine();
			
			if(s.ToLower() == "exit"){
				break;
			}
			
			try{
				CommandLineHandler.process(StringHelper.splitSentence(s));
			}catch(TebasError te){
				Console.WriteLine(te);
			}catch(TebasCriticalError tce){
				Console.WriteLine(tce);
			}
			
			consoleOutput("");
		}
	}
	
	//Other thingies
	
	static bool projectExists(string channelPath, string name){
		if(!Directory.Exists(channelPath + "/" + name)){
			return false;
		}
		if(!File.Exists(channelPath + "/" + name + "/project.tebas")){
			return false;
		}
		return true;
	}
	
	public static bool askDeletionConfirmation(){
		initializeConfig();
		if(config.CanGetCamp("deletionConfirmationNeeded", out bool b) && !b){
			return true;
		}
		Console.WriteLine("Are you sure you want to delete it? (Y/N)");
		string ans = Console.ReadLine();
		
		if(ans.ToLower() == "y"){
			return true;
		}
		return false;
	}
	
	//maybe it works 
	static List<string> GetFilesWithExtensions(string directoryPath, string[] extensions, string[] blacklistPaths)
	{
		return Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories) // Recursively get all files
						.Where(file => extensions.Contains(Path.GetExtension(file), StringComparer.OrdinalIgnoreCase) &&
						!blacklistPaths.Any(blacklisted => Path.GetFullPath(file).StartsWith(Path.GetFullPath(blacklisted), StringComparison.OrdinalIgnoreCase)))
						.ToList();
	}
	
	//output
	public static void consoleOutput(string s){
		if(!quiet){
			Console.WriteLine(s);
		}
	}
	
	static void scriptOutput(string s){
		if(!quiet){
			Console.WriteLine(s);
		}
	}
}