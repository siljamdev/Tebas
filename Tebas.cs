using System;
using AshLib.Formatting;
using AshLib.AshFiles;
using AshLib.Folders;
using AshLib.Dates;
using AshLib;

class Tebas{
	//Context variables
	
	public static bool quiet;
	public static bool forced;
	
	public static Dependencies dep;
	public static AshFile config;
	
	public static AshFile? template;
	public static string tn; //templateName
	public static string templateDirectory;
	
	public static AshFile? project;
	public static string pn; //projectName
	
	public static string workingDirectory;
	
	//private initilization vars
	private static bool configInit;
	private static bool localInit;
	
	public const string currentVersion = "0.5.2";
	
	public static readonly CharFormat severeErrorCharFormat = new CharFormat(Color3.Red);
	public static readonly CharFormat errorCharFormat = new CharFormat(new Color3("E54548"));
	public static readonly CharFormat blueCharFormat = new CharFormat(new Color3("00AFFF"));
	
	public static void Main(string[] args){
		workingDirectory = Directory.GetCurrentDirectory();
		
		initialize();
		
		initializeConfig();
		
		//DebugHelper.firstTest();
		
		try{
			CommandLineHandler.process(args);
		}catch(TebasError te){
			Console.WriteLine(te);
		}catch(TebasCriticalError tce){
			Console.WriteLine(tce);
		}
		
	}
	
	//Initialize methods
	
	static void initialize(){
		string appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
		dep = new Dependencies(appDataPath + "/ashproject/tebas", true, new string[]{"templates"}, null);
	}
	
	public static void initializeConfig(){
		if(configInit){
			return;
		}
		
		config = dep.config;
		
		AshFileModel m = new AshFileModel(
			new ModelInstance(ModelInstanceOperation.Type, "deletionConfirmationNeeded", true),
			new ModelInstance(ModelInstanceOperation.Type, "scriptShowsName", false),
			new ModelInstance(ModelInstanceOperation.Type, "processShowsName", true),
			new ModelInstance(ModelInstanceOperation.Type, "projectRecursiveSearch", true),
			new ModelInstance(ModelInstanceOperation.Type, "useColors", true),
			new ModelInstance(ModelInstanceOperation.Type, "defaultReadme", "Auto generated by Tebas project manager" + Environment.NewLine),
			new ModelInstance(ModelInstanceOperation.Type, "git.autoAddOnCommit", false),
			new ModelInstance(ModelInstanceOperation.Type, "git.defaultGitignore", "#Auto generated by Tebas project manager" + Environment.NewLine + "/desktop.ini" + Environment.NewLine + ".git/" + Environment.NewLine + "/.gitignore" + Environment.NewLine + "/project.tebas"),
			new ModelInstance(ModelInstanceOperation.Type, "git.path", "git"),
			new ModelInstance(ModelInstanceOperation.Type, "git.defaultBranch", "main")
		);
		
		m.deleteNotMentioned = true; 
		
		config *= m;
		
		config.format = 3;
		
		config.Save();
		configInit = true;
		
		FormatString.usesColors = !Console.IsOutputRedirected && config.CanGetCamp("useColors", out bool b) && b;
	}
	
	public static bool initializeLocal(){
		if(localInit){
			return true;
		}
		
		if(!setContextLocal()){
			return false;
		}
		
		if(project.CanGetCamp("template", out string ten)){
			setContextTemplate(ten);
		}else{
			consoleError("The local project has no referenced template: bad formatting of project.tebas");
		}
		
		localInit = true;
		return true;
	}
	
	public static bool initializeLocalSilent(){
		if(localInit){
			return true;
		}
		
		if(!setContextLocal()){
			return false;
		}
		
		if(project.CanGetCamp("template", out string ten)){
			setContextTemplate(ten);
		}
		
		localInit = true;
		return true;
	}
	
	//attempt to tidy this up :'(
	
	public static bool setContextTemplate(string templateName){
		if(!TemplateHandler.exists(templateName)){
			consoleError("The template '" + templateName + "' is not installed");
			return false;
		}
		
		tn = templateName;
		
		template = TemplateHandler.get(tn);
		
		templateDirectory = templateDirectory = dep.path + "/templates/" + tn;
		//workingDirectory = templateDirectory; //Because if only template then this ykyk (i have no idea of what im doing)
		
		return true;
	}
	
	public static bool setContextLocal(){ //project
		initializeConfig();
		
		string f = workingDirectory;
		while(true){
			if(File.Exists(f + "/project.tebas")){
				break;
			}
			
			if(config.CanGetCamp("projectRecursiveSearch", out bool b) && !b){
				consoleError("There is no local project in this folder: " + workingDirectory);
				return false;
			}
			
			f = Path.GetDirectoryName(f);
			if(f == null){
				consoleError("There is no local project in this folder: " + workingDirectory);
				return false;
			}
		}
		
		workingDirectory = f;
		
		project = new AshFile(workingDirectory + "/project.tebas");
		
		pn = Path.GetFileName(workingDirectory);
		
		return true;
	}
	
	public static bool setContextFull(){ //project and template, from local source
		initializeConfig();
		
		string f = workingDirectory;
		while(true){
			if(File.Exists(f + "/project.tebas")){
				break;
			}
			
			if(config.CanGetCamp("projectRecursiveSearch", out bool b) && !b){
				consoleError("There is no local project in this folder: " + workingDirectory);
				return false;
			}
			
			f = Path.GetDirectoryName(f);
			if(f == null){
				consoleError("There is no local project in this folder: " + workingDirectory);
				return false;
			}
		}
		
		workingDirectory = f;
		
		project = new AshFile(workingDirectory + "/project.tebas");
		
		pn = Path.GetFileName(workingDirectory);
		
		if(project.CanGetCamp("template", out string t)){
			if(!TemplateHandler.exists(t)){
				consoleError("The template referenced in this project is not installed: " + t);
				return false;
			}
			tn = t;
			
			template = TemplateHandler.get(tn);
			
			templateDirectory = dep.path + "/templates/" + tn;
			return true;
		}else{
			consoleError("The local project has no referenced template: bad formatting of project.tebas");
			return false;
		}
	}
	
	public static bool setContextFullSilent(){ //project and template, from local source
		initializeConfig();
		
		string f = workingDirectory;
		while(true){
			if(File.Exists(f + "/project.tebas")){
				break;
			}
			
			if(config.CanGetCamp("projectRecursiveSearch", out bool b) && !b){
				return false;
			}
			
			f = Path.GetDirectoryName(f);
			if(f == null){
				return false;
			}
		}
		
		workingDirectory = f;
		
		project = new AshFile(workingDirectory + "/project.tebas");
		
		pn = Path.GetFileName(workingDirectory);
		
		if(project.CanGetCamp("template", out string t)){
			if(!TemplateHandler.exists(t)){
				return false;
			}
			tn = t;
			
			template = TemplateHandler.get(tn);
			
			templateDirectory = dep.path + "/templates/" + tn;
			return true;
		}else{
			return false;
		}
	}
	
	//Commands
	
	public static void version(){
		Console.WriteLine("Current version: v" + currentVersion);
		Console.WriteLine("Tebas project manager, created by Siljam");
		Console.WriteLine();
		Console.WriteLine("GitHub repo: https://github.com/siljamdev/Tebas");
		Console.WriteLine("Find many useful templates and plugins there!");
	}
	
	//Project
	
	public static void projectNew(string channelName, string templateName, string projectName){
		initializeConfig();
		
		string folderPath;
		
		if(!ChannelHandler.canGetPath(channelName, out folderPath)){
			consoleError("That channel does not exist");
			return;
		}
		
		if(!setContextTemplate(templateName)){
			return;
		}
		
		if(projectExists(folderPath, projectName)){
			consoleError("That project already exists");
			return;
		}
		
		pn = projectName;
		
		workingDirectory = folderPath + "/" + projectName;
		
		consoleOutput("Attempting to create in channel '" + channelName + "', folder '" + folderPath + "'");
		
		Directory.CreateDirectory(workingDirectory);
		Directory.SetCurrentDirectory(workingDirectory);
		
		project = new AshFile();
		
		project.SetCamp("template", templateName);
		project.SetCamp("creationDate", (Date) DateTime.Now);
		
		if(template.CanGetCamp("git.defaultUse", out bool b) && b){
			project.SetCamp("git.use", true);
			
			GitHelper.init();
			
			GitHelper.addGitignore();
		}else{
			project.SetCamp("git.use", false);
		}
		
		if((!template.CanGetCamp("addReadme", out b) || b) && !File.Exists(workingDirectory + "/README.md")){
			string readme = "";
			if(config.CanGetCamp("defaultReadme", out string s)){
				readme = s;
			}
			
			if(template.CanGetCamp("readme", out string t)){
				readme += t;
			}
			
			if(readme.Length > 0){
				File.WriteAllText(workingDirectory + "/README.md", readme);
			}
		}
		
		project.Save(workingDirectory + "/project.tebas");
		
		TemplateHandler.runScript("new");
		
		consoleOutput("Project succesfully created");
	}
	
	public static void projectRename(string channelName, string oldName, string newName){
		string folderPath;
		
		if(!ChannelHandler.canGetPath(channelName, out folderPath)){
			consoleError("That channel does not exist");
			return;
		}

		if(!projectExists(folderPath, oldName)){
			consoleError("That project you want to rename does not exist");
			return;
		}
		
		if(projectExists(folderPath, newName)){
			consoleError("That name is already in use");
			return;
		}
		
		pn = oldName;
		
		workingDirectory = folderPath + "/" + oldName;
		
		consoleOutput("Attempting to rename in channel " + channelName + ", folder \"" + folderPath + "\"");
		
		Directory.Move(workingDirectory, folderPath + "/" + newName);
		
		workingDirectory = folderPath + "/" + newName;
		
		Directory.SetCurrentDirectory(workingDirectory);
		
		pn = newName;
		
		TemplateHandler.runScript("rename");
		
		consoleOutput("Project succesfully renamed");
	}
	
	public static void projectDelete(string channelName, string name){
		string folderPath;
		
		if(!ChannelHandler.canGetPath(channelName, out folderPath)){
			consoleError("That channel does not exist");
			return;
		}

		if(!projectExists(folderPath, name)){
			consoleError("That project does not exist");
			return;
		}
		
		if(!forced && !askDeletionConfirmation()){
			consoleOutput("Deletion cancelled");
			return;
		}
		
		consoleOutput("Attempting to delete in channel " + channelName + ", folder \"" + folderPath + "\"");
		
		Directory.Delete(folderPath + "/" + name, true);
		
		consoleOutput("Project succesfully deleted");
	}
	
	//Global
	public static void globalConfig(string key, string val){
		initializeConfig();
		
		switch(key){
			case "list":
			consoleOutput("List of config options:");
			consoleOutput("  deleteConfirm     - If you have to confirm every deletion");
			consoleOutput("  scriptLogName     - If template scripts will show the name of the script");
			consoleOutput("  processLogName    - If external processes will show their name");
			consoleOutput("  recursiveSearch   - If the 'project.tebas' file will be searched recurisvely upwards");
			consoleOutput("  useColors         - Enable or disable completely ANSI coloring");
			consoleOutput("  readme            - The default readme file for projects. Requires a file path");
			consoleOutput("  gitignore         - The default .gitignore file for projects that use git. Requires a file path");
			consoleOutput("  gitPath           - The path to the git executable");
			consoleOutput("  gitDefaultBranch  - The default branch that will be used for all git related stuff");
			consoleOutput("  gitAddOnCommit    - Automatically adds all changes when commiting");
			break;
			
			case "deleteConfirm":
			setConfigTrueFalse("deletionConfirmationNeeded", val);
			break;
			
			case "scriptLogName":
			setConfigTrueFalse("scriptShowsName", val);
			break;
			
			case "processLogName":
			setConfigTrueFalse("processShowsName", val);
			break;
			
			case "recursiveSearch":
			setConfigTrueFalse("projectRecursiveSearch", val);
			break;
			
			case "useColors":
			setConfigTrueFalse("useColors", val);
			break;
			
			case "readme":
			if(!File.Exists(val)){
				consoleOutput("That file does not exsist");
				break;
			}
			config.SetCamp("defaultReadme", File.ReadAllText(val));
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitignore":
			if(!File.Exists(val)){
				consoleOutput("That file does not exsist");
				break;
			}
			config.SetCamp("git.defaultGitignore", File.ReadAllText(val));
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitPath":
			config.SetCamp("git.path", val);
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitDefaultBranch":
			config.SetCamp("git.defaultBranch", val);
			config.Save();
			consoleOutput("Config changed correctly");
			break;
			
			case "gitAddOnCommit":
			setConfigTrueFalse("git.autoAddOnCommit", val);
			break;
			
			case "see":
			consoleOutput("Current config values:");
			
			if(config.CanGetCamp("deletionConfirmationNeeded", out bool deleteConfirm)){
				consoleOutput("  deleteConfirm: " + deleteConfirm);
			}
			
			if(config.CanGetCamp("scriptShowsName", out bool scriptLogName)){
				consoleOutput("  scriptLogName: " + scriptLogName);
			}
			
			if(config.CanGetCamp("processShowsName", out bool processLogName)){
				consoleOutput("  processLogName: " + processLogName);
			}
			
			if(config.CanGetCamp("projectRecursiveSearch", out bool recursiveSearch)){
				consoleOutput("  recursiveSearch: " + recursiveSearch);
			}
			
			if(config.CanGetCamp("useColors", out bool useColors)){
				consoleOutput("  useColors: " + useColors);
			}
			
			if(config.CanGetCamp("defaultReadme", out string readme)){
				string[] p = readme.splitLines();
				
				bool b = true;
				foreach(string s in p){
					if(b){
						consoleOutput("  readme: " + s);
						b = false;
					}else{
						consoleOutput("          " + s);
					}
				}
			}
			
			if(config.CanGetCamp("git.defaultGitignore", out string gitignore)){
				string[] p = gitignore.splitLines();
				
				bool b = true;
				foreach(string s in p){
					if(b){
						consoleOutput("  gitignore: " + s);
						b = false;
					}else{
						consoleOutput("             " + s);
					}
				}
			}
			
			if(config.CanGetCamp("git.path", out string gitPath)){
				consoleOutput("  gitPath: " + gitPath);
			}
			
			if(config.CanGetCamp("git.defaultBranch", out string gitDefaultBranch)){
				consoleOutput("  gitDefaultBranch: " + gitDefaultBranch);
			}
			
			if(config.CanGetCamp("git.autoAddOnCommit", out bool gitAddOnCommit)){
				consoleOutput("  gitAddOnCommit: " + gitAddOnCommit);
			}
			break;
			
			default:
			consoleError("That key isnt a config option. Do \'config list\' to see the full list");
			break;
		}
	}
	
	public static void globalList(){
		string[] names = ChannelHandler.allNames();
		
		if(names.Length > 0){
			consoleOutput("Full list of projects: ");
		}else{
			consoleOutput("  No channels exist");
		}
		
		foreach(string n in names){
			consoleOutput("  Channel: " + n);
			
			if(!Directory.Exists(ChannelHandler.getPath(n))){
				continue;
			}
			List<string> projects = ChannelHandler.allProjects(n);
			
			if(projects.Count == 0){
				consoleOutput("      No projects here (yet!)");
			}
			
			foreach(string s in projects){
				consoleOutput("      " + Path.GetFileName(s));
			}
		}
	}
	
	public static void globalStats(){
		string[] names = ChannelHandler.allNames();
		
		if(names.Length > 0){
			consoleOutput("Lines of code, by channel: ");
		}else{
			consoleOutput("  No channels exist");
		}
		
		int l = 0;
		
		foreach(string n in names){
			l += ChannelHandler.statsShort(n);
		}
		
		Tebas.consoleOutput("Total lines of code: " + l);
	}
	
	static void setConfigTrueFalse(string key, string val){
		val = val.ToLower();
		if(val == "true"){
			config.SetCamp(key, true);
			config.Save();
			consoleOutput("Config changed correctly");
		}else if(val == "false"){
			config.SetCamp(key, false);
			config.Save();
			consoleOutput("Config changed correctly");
		}else{
			consoleError("The value must be either 'true' or 'false'");
		}
	}
	
	//local
	
	public static void localInfo(){
		if(!initializeLocal()){
			return;
		}
		
		consoleOutput("Project name: " + pn);
		consoleOutput("Project folder: " + workingDirectory);
		if(project.CanGetCamp("creationDate", out Date d)){
			consoleOutput("Date of creation: " + d);
		}
		
		
		if(!TemplateHandler.exists(tn)){
			return;
		}
		
		consoleOutput("Template in use: " + tn);
		
		TemplateHandler.runScript("info");
	}
	
	public static void localGitStartUsing(){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			consoleError("Git is already used in this project");
			return;
		}
		
		project.SetCamp("git.use", true);
		project.Save();
		
		GitHelper.tryInit();
		
		GitHelper.addGitignore();
		
		consoleOutput("Git was started correctly");
	}
	
	public static void localGitStopUsing(){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && !b){
			consoleError("Git is already not in use in this project");
			return;
		}
		
		project.SetCamp("git.use", false);
		project.Save();
		
		consoleOutput("Git was stopped correctly");
	}
	
	public static void localGit(){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.status();
			TemplateHandler.runScript("git");
		}else{
			consoleError("Git is not used in this project");
		}
	}
	
	public static void localSetBranch(string branch){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.setWorkingBranch(branch);
			TemplateHandler.runScript("setBranch", new string[]{branch});
		}else{
			consoleError("Git is not used in this project");
		}
	}
	
	public static void localStats(){
		if(!setContextFull()){
			return;
		}
		
		if(!template.CanGetCamp("codeExtensions", out string x)){
			consoleOutput("The template does not have code file extensions");
			TemplateHandler.runScript("stats");
			return;
		}
		
		if(!template.CanGetCamp("codeFilesFolderBlacklist", out string b)){
			b = "";
		}
		
		string[] exs = x.splitLines();
		List<string> bs = b.splitLines().ToList();
		
		for(int i = 0; i < bs.Count; i++){
			if(bs[i] == ""){
				bs.RemoveAt(i);
				i--;
				continue;
			}
			bs[i] = workingDirectory + "/" + bs[i];
		}
		
		List<string> files = GetFilesWithExtensions(workingDirectory, exs, bs.ToArray());
		
		int l = 0;
		foreach(string p in files){
			l += File.ReadAllLines(p).Length;
		}
		
		consoleOutput("Total number of code lines: " + l);
		
		TemplateHandler.runScript("stats");
	}
	
	public static int getNumberOfLinesOfCode(){
		if(!setContextFullSilent()){
			return 0;
		}
		
		if(!template.CanGetCamp("codeExtensions", out string x)){
			return 0;
		}
		
		if(!template.CanGetCamp("codeFilesFolderBlacklist", out string b)){
			b = "";
		}
		
		string[] exs = x.splitLines();
		List<string> bs = b.splitLines().ToList();
		
		for(int i = 0; i < bs.Count; i++){
			if(bs[i] == ""){
				bs.RemoveAt(i);
				i--;
				continue;
			}
			bs[i] = workingDirectory + "/" + bs[i];
		}
		
		List<string> files = GetFilesWithExtensions(workingDirectory, exs, bs.ToArray());
		
		int l = 0;
		foreach(string p in files){
			l += File.ReadAllLines(p).Length;
		}
		
		return l;
	}
	
	public static void localAdd(){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.add();
			
			TemplateHandler.runScript("add");
		}else{
			consoleError("Git is not used in this project");
		}
	}
	
	public static void localCommit(string m){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.commit(m);
			
			TemplateHandler.runScript("commit", new string[]{m});
		}else{
			consoleError("Git is not used in this project");
		}
	}
	
	public static void localPush(string r){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.push(r);
			
			TemplateHandler.runScript("push");
		}else{
			consoleError("Git is not used in this project");
		}
	}
	
	public static void localPull(string r){
		if(!initializeLocal()){
			return;
		}
		
		if(project.CanGetCamp("git.use", out bool b) && b){
			GitHelper.pull(r);
			
			TemplateHandler.runScript("pull");
		}else{
			consoleError("Git is not used in this project");
		}
	}
	
	public static void localInitNew(string templateName){
		initializeConfig();
		
		string folderPath = workingDirectory;
		
		if(!setContextTemplate(templateName)){
			return;
		}
		
		if(File.Exists("project.tebas")){
			consoleError("There is a project already here");
			return;
		}
		
		pn = Path.GetFileName(folderPath);
		
		project = new AshFile();
		
		project.SetCamp("template", templateName);
		project.SetCamp("creationDate", (Date) DateTime.Now);
		
		if(template.CanGetCamp("git.defaultUse", out bool b) && b){
			project.SetCamp("git.use", true);
			
			GitHelper.init();
			
			string gitIgnore = "";
			if(config.CanGetCamp("git.defaultGitignore", out string k)){
				gitIgnore = k;
			}
			
			if(template.CanGetCamp("git.gitignore", out k)){
				gitIgnore += "\n" + k;
			}
			
			if(gitIgnore.Length > 0 && !File.Exists(workingDirectory + "/.gitignore")){
				File.WriteAllText(workingDirectory + "/.gitignore", gitIgnore);
			}
		}else{
			project.SetCamp("git.use", false);
		}
		
		if(template.CanGetCamp("addReadme", out b) && b){
			string readme = "";
			if(config.CanGetCamp("defaultReadme", out string s)){
				readme = s;
			}
			
			if(template.CanGetCamp("readme", out s)){
				readme += s;
			}
			
			if(readme.Length > 0 && !File.Exists(workingDirectory + "/README.md")){
				File.WriteAllText(workingDirectory + "/README.md", readme);
			}
		}
		
		project.Save(workingDirectory + "/project.tebas");
		
		TemplateHandler.runScript("new");
		
		consoleOutput("Project succesfully initiallized locally");
	}
	
	//local config remote
	
	public static void localRemoteList(){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.printAllRemotes();
	}
	
	public static void localRemoteSet(string n, string u){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.remoteSet(n, u);
	}
	
	public static void localRemoteDelete(string n){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.remoteDelete(n);
	}
	
	public static void localRemoteRename(string o, string n){
		if(!initializeLocal()){
			return;
		}
		
		GitHelper.remoteRename(o, n);
	}
	
	//Template scripts
	
	public static bool tryScript(string name){
		if(!initializeLocalSilent()){
			consoleSevereError("Unknown command: " + name);
			return false;
		}
		
		if(!TemplateHandler.runScript(name)){
			consoleSevereError("Unknown command or script: " + name);
			return false;
		}
		
		return true;
	}
	
	public static bool tryScript(string name, IEnumerable<string> args){
		if(!initializeLocalSilent()){
			consoleSevereError("Unknown command: " + name);
			return false;
		}
		
		if(!TemplateHandler.runScript(name, args)){
			consoleSevereError("Unknown command or script: " + name);
			return false;
		}
		
		return true;
	}
	
	//Standalone scripts
	public static void runStandaloneScript(string filePath){
		filePath = StringHelper.removeQuotesSingle(filePath);
		
		if(!File.Exists(filePath)){
			consoleError("File not found");
			return;
		}
		
		AshFile te = template;
		string t = tn;
		string td = templateDirectory;
		AshFile pj = project;
		string p = pn;
		
		template = null;
		tn = "";
		templateDirectory = "";
		project = null;
		pn = "";
		
		Script s = new Script(Path.GetFileNameWithoutExtension(filePath), File.ReadAllText(filePath));
		s.run(null);
		
		template = te;
		tn = t;
		templateDirectory = td;
		project = pj;
		pn = p;
	}
	
	public static void runStandaloneScript(string filePath, IEnumerable<string> args){
		filePath = StringHelper.removeQuotesSingle(filePath);
		
		if(!File.Exists(filePath)){
			consoleError("File not found");
			return;
		}
		
		AshFile te = template;
		string t = tn;
		string td = templateDirectory;
		AshFile pj = project;
		string p = pn;
		
		template = null;
		tn = "";
		templateDirectory = "";
		project = null;
		pn = "";
		
		Script s = new Script(Path.GetFileNameWithoutExtension(filePath), File.ReadAllText(filePath));
		s.run(args);
		
		template = te;
		tn = t;
		templateDirectory = td;
		project = pj;
		pn = p;
	}
	
	//loop
	public static void loop(){
		if(!isConsoleInteractive()){
			consoleSevereError("An intreractive console is needed to run this command");
			return;
		}
		Tebas.quiet = false;
		consoleOutput(" Exit typing 'exit'");
		string s;
		while(true){
			Console.Write(">");
			s = Console.ReadLine();
			
			if(s.ToLower() == "exit"){
				break;
			}
			
			try{
				CommandLineHandler.process(StringHelper.splitSentence(s));
			}catch(TebasError te){
				consoleSevereError(te.ToString());
			}catch(TebasCriticalError tce){
				consoleSevereError(tce.ToString());
			}
			
			consoleOutput("");
		}
	}
	
	//Other thingies
	
	static bool projectExists(string channelPath, string name){
		if(!Directory.Exists(channelPath + "/" + name)){
			return false;
		}
		if(!File.Exists(channelPath + "/" + name + "/project.tebas")){
			return false;
		}
		return true;
	}
	
	public static bool askDeletionConfirmation(){
		initializeConfig();
		if(config.CanGetCamp("deletionConfirmationNeeded", out bool b) && !b){
			return true;
		}
		if(!isConsoleInteractive()){
			return true;
		}
		Console.WriteLine("Are you sure you want to delete it? (Y/N)");
		string ans = Console.ReadLine();
		
		if(ans.ToLower() == "y"){
			return true;
		}
		return false;
	}
	
	public static int isVersionNewer(string vs){ //0 is same version or error (continue), 1 is older version, -1 is newer version(cancel)
		string[] c = currentVersion.Split(".");
		if(c.Length != 3){
			return 0;
		}
		
		if(!int.TryParse(c[0], out int c1) || !int.TryParse(c[1], out int c2) || !int.TryParse(c[2], out int c3)){
			return 0;
		}
		
		string[] v = vs.Split(".");
		if(v.Length != 3){
			return 0;
		}
		
		if(!int.TryParse(v[0], out int v1) || !int.TryParse(v[1], out int v2) || !int.TryParse(v[2], out int v3)){
			return 0;
		}
		
		if(c1 < v1){
			return -1;
		}else if(c1 > v1){
			return 1;
		}else{
			if(c2 < v2){
				return -1;
			}else if(c2 > v2){
				return 1;
			}else{
				if(c3 < v3){
					return -1;
				}else if(c3 > v3){
					return 1;
				}else{
					return 0;
				}
			}
		}
	}
	
	public static bool isConsoleInteractive(){
		return Environment.UserInteractive && !Console.IsInputRedirected && !Console.IsOutputRedirected;
	}
	
	//maybe it works 
	static List<string> GetFilesWithExtensions(string directoryPath, string[] extensions, string[] blacklistPaths)
	{
		return Directory.GetFiles(directoryPath, "*", SearchOption.AllDirectories) // Recursively get all files
						.Where(file => extensions.Contains(Path.GetExtension(file), StringComparer.OrdinalIgnoreCase) &&
						!blacklistPaths.Any(blacklisted => Path.GetFullPath(file).StartsWith(Path.GetFullPath(blacklisted), StringComparison.OrdinalIgnoreCase)))
						.ToList();
	}
	
	public static bool useColors(){
		initializeConfig();
		
		return FormatString.usesColors;
	}
	
	//output
	public static void consoleOutput(string s){
		if(!quiet){
			Console.WriteLine(s);
		}
	}
	
	public static void consoleError(string s){
		initializeConfig();
		
		if(!quiet){
			if(useColors()){
				FormatString fs = new FormatString(s, errorCharFormat);
				Console.Error.WriteLine(fs);
			}else{
				Console.Error.WriteLine(s);
			}
		}
	}
	
	public static void consoleSevereError(string s){
		initializeConfig();
		
		if(useColors()){
			FormatString fs = new FormatString(s, severeErrorCharFormat);
			Console.Error.WriteLine(fs);
		}else{
			Console.Error.WriteLine(s);
		}
	}
}